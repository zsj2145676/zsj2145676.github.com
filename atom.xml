<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[CRESCENDO]]></title>
  <subtitle><![CDATA[花开堪折直须折 | gather ye rosebuds while ye may]]></subtitle>
  <link href="http://shujian.me//atom.xml" rel="self"/>
  <link href="http://shujian.me/"/>
  <updated>2013-08-01T07:42:58.076Z</updated>
  <id>http://shujian.me//</id>
  <author>
    <name><![CDATA[Shukri Chiu]]></name>
    <email><![CDATA[zsj.jacob@gmail.com]]></email>
  </author>
  <generator uri="http://zespia.tw/hexo">Hexo</generator>
  <entry>
    <title type="html"><![CDATA[Behance -- 创意人士高效工作十法则]]></title>
    <link href="http://shujian.me//2013/07/22/behance/"/>
    <id>http://shujian.me//2013/07/22/behance/</id>
    <published>2013-07-21T16:00:00.000Z</published>
    <updated>2013-08-01T05:07:56.041Z</updated>
    <content type="html"><![CDATA[<h3>1.避免犹豫迟疑 Break the seal of hesitation</h3>
<p>在我们采访到的成百位创意专家和企业家中，这点是最明显的共同点。在开始一个项目时，适当的准备是值得的，但同时也要注意，在后期也要时刻有所准备，因为如果没有明确的规划，会很容易迷失方向。我们必须清楚，越早行动越好。因为当你开始行动了（比如建某个模型的雏形，和你的团队分享一个萌芽期的点子之类的），你就会同时得到有价值的意见回馈，这会帮助完善你最初的想法，由此将其推向更加明智的发展方向。 </p>
<h3>2.从小处开始 Start small</h3>
<p>每当我们刚有一个想法时，往往习惯好高骛远。这样的缺点是难以付诸实践。为了避免这样的“蓝图主义”，就要将你的创想定的小一点，可以立刻实行起来的。你可以想想，通过几天的节假日，这个主意是否可以做出点成效来？可不可以将你大大的构想，缩小缩小在缩小？一旦你将自己精简版的创想实践过后，对于怎样进行后续步骤，会更加有把握。</p>
<h3>3.将点子付诸实践，反复优化和尝试 Protoype, prototype, prototype</h3>
<p>生活中，当创意遭遇失败，是家常便饭。网略喜剧艺术家泽·弗兰克就说过，当我们第一次执行一个想法时，通常都会遭人唾弃。重要的是你要吸收其中的经验教训，以此来完善你的想法，更新升级。很多创意达人的例子，比如之前提到的杰克·多尔西、本·考夫曼和Studio 7.5，都证实了——实现创想的关键是要为创意点子设计原型和迭代设计。这比你一直沉浸于挫败的情绪之中更为积极有价值。必须要认识到失败乃成功之母。从哪里跌倒，就从哪里爬起，重新想一套实践方案，再干起来。一次次之后，你总会成功。 </p>
<blockquote>
<p>With projects that require a serious infusion of creative juice,it&#39;s incredibly important to maintain momentum</p>
</blockquote>
<p><a name="more"></a></p>
<h3>4.明确项目的目标，写下来，定期审视回顾 Create simple objectives for projects, and revisit them regularly.</h3>
<p>当进程发展到一定阶段时，我们也会不时被激发出很多新的灵感和主意。这会导致目标膨胀或者由小扩大。 我们便会想到，这不就永远实现不了目标了么。避免这种情况的最好方法是，一开始就把总结好的目标写下来。（如果有合作伙伴的，就需要一起协商好再定目标。）这个是经常被我们忽视的部分，当发现哪天计划超出范围了，你就会发现它的作用了。 </p>
<h3>5.通过每天完成一定的量来完成项目Work on your project a little bit each day.</h3>
<p>对于需要创新的事情来说，很重要的一点就是激情，比如开发一个新业务、写小说或者就是学一门新的技术。就好比你每天跑步，跑了越多，越觉得容易，因为你已经习惯了。创新也一样，每天激发一下，到后来就变得很得心应手了。Jack Cheng 发表过一篇著名的博客“Thirty Minutes A Day”，他说，“重要的不是你做了多少，而是多久做一次。” </p>
<h3>6.制定清晰的时间表 Develop a routine</h3>
<p>每天能否做一点，大部分是由你安排的时间表来决定的。时间表看似很无趣乏味，其实不然，它是激发你灵感的基础。村上春树在最近发表的回忆录《当我跑步时我在谈什么》中，就写到，严密的时间表对激发创意是多么的重要。（书中提到，埃里克斯·伊斯科德就曾在创业初期时，从此书中受益匪浅）。</p>
<h3>7.将长期的目标细分多个阶段，并为每阶段制定目标 Break big, long-term projects into smaller chunks or “phases.”</h3>
<p>为了帮助达到期望和保持长期的动力，有必要花上几周或一个月的时间，将宏大的项目细分一下。这样做的好处：1）便于管理项目进程；2）增加收益回报率。尽管还不知道何时可以达成目标，但定期进行反思和评估，这是非常重要的。 </p>
<h3>8.精简会议次数和与会人数 Prune away superfluous meetings (and their attendees)</h3>
<p>一个商业项目的开始，必然伴随着很多会议的产生。如果一定要开会，注意是如果，那就要在开始前明确好目的。如果与会人员与此次会议没什么关系，那就不必让他们参加了。近日《纽约时报》的就业专栏采访到了Qwest 的首席运营官特蕾莎·泰勒，她谈到，每次她都会以“我们为什么在这”的提问开始会议，之后还会问“每个人都需要出席吗？”。为了使会议高效运转，还可以站着开会。 </p>
<h3>9.尝试着说“不” Practice saying “No.”</h3>
<p>我们不会一直抱有创新的激情。睿智的创意家懂得如何保持这份激情和执着。就拿杰米·科林斯来说，他的小说《从优秀到卓越》销售量已近上百万册了。大家都很追捧他的商业敏锐度和洞察力。尽管他每演讲一次就可赚到6万美金，但一年演讲数不会超过18次。否则，科林斯就无法将足够的时间和精力花在研究和写作上，也不会诞生如此畅销的著作。当我们在做事的时候，要记得：那些突如其来的机会往往会干扰你当下的工作。懂得拒绝是提高效率的必要因素。 </p>
<h3>10.记住一条规律：所有法则在必要时都可以被打破 Remember that rules - even productivity rules - are made to be broken.</h3>
<p>我们之前提到过要制定一个时间表。对于这点和其他的一些方法，只有当真正有成效，才需要执行。如果当下一步进程与你初定的时间计划不一致的时候，你就需要重新再定一个。就好比长途旅行，你总会不时蹦出一些想法，一会逛逛博物馆，一会走走街区，又或是和陌生人聊天，要确保偶尔更新一下自己的时间计划。打破常规，会带给我们新的希望，也会帮助我们很好的保持精力而避免烦躁。</p>
]]></content>
    <category scheme="http://shujian.me//tags/Behance/" term="Behance"/>
    <category scheme="http://shujian.me//tags/creative/" term="creative"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[是厌恶]]></title>
    <link href="http://shujian.me//2013/06/26/annoyer/"/>
    <id>http://shujian.me//2013/06/26/annoyer/</id>
    <published>2013-06-25T16:00:00.000Z</published>
    <updated>2013-08-01T05:26:29.687Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>“在编程的殿堂里，有三种人，一种是爱好编程的人，编程给了他们超乎常人的智力上的满足；第二种，是为了生计为了功利而来的人；但编程的殿堂之所以存在，不取决于前两种人，而依赖第三种人，他们喜爱编程，是因为要逃避日常生活中令人厌恶的粗俗的使人绝望的沉闷。”    </p>
<footer>阿尔伯特·爱因斯坦</footer>

</blockquote>
<p>引言改编自知乎上一篇关于「一个人至少应该有什么样的特质,才能写小说，当作家?」.当然小说是很文艺的,但是一上编程顿时三俗感就冒出来了。。。原文很长，以爱好者，职业人，逃避者三个角度借喻老苍蝇、黄饺子、凉青蛙再加上充满淡淡忧伤的文风很形象的将这种特质刻了出来。其中厌恶一段实在深得我心，大意是厌恶是“我偏不”的一种极端表现,极端到连对“厌恶”本身也是一种厌恶。但是作为一种意识体的反射天性，能够善于使用这种力量的,能够用强大理性控制矛与盾并持续交织运用的,就是天才。哈哈,写的太玄乎，在我看来就是EASON老师几句话嘛。。  <a name="more"></a></p>
<p><img src="http://sergio-blog.qiniudn.com/eason_1.png" alt="">
<img src="http://sergio-blog.qiniudn.com/eason_2.png" alt="">
<img src="http://sergio-blog.qiniudn.com/eason_3.png" alt=""></p>
<p>好吧，我也不是有意拉低逼格的。只不过虽然想表达的意思跟原作相似，但是风格不同我也模仿不出来。我看事情很简单，绕来绕去无非一个态度和角度。选择厌恶也是一种态度,以厌恶的态度来创做就是一种角度。在动手开始做一件事之前总会受到很多的影响,比如编程，&quot;编程多苦逼啊,一天到晚都对着电脑&quot;,&quot;程序员找不到女朋友&quot;,&quot;程序员各种猝死&quot;,&quot;程序员除了乔布斯都长的丑不拉几&quot;。  </p>
<p>对于前几点我都认了！最后一点坚决不能同意！看看人家twitter创始人Jack Dorsey<br><img src="http://sergio-blog.qiniudn.com/jkd_2.jpg" alt=""><br>再看看37signals co-founder Jason Fried<br><img src="http://sergio-blog.qiniudn.com/jason.fried.jpg" alt=""><br>尼玛，老子老板都是一表人才有木有！<br><img src="http://sergio-blog.qiniudn.com/jerry.jpg" alt="">  </p>
<p>咳咳,回归正题!我想表达的只是对这种“厌恶”态度兼角度按个赞。因为喜欢去做一件事就包含着为了这份喜欢我愿意忍受与之相关的各种困难，各种负面因素;但是因为厌恶去做一件事，就好像负面因素对你本来就不能够造成影响一样。再黑次程序员吧,有的人真心喜欢编程，所以愿意牺牲自己的休息时间，愿意选择一个相对狭小的生活圈子，愿意忍受孤独;那另一种人呢？我就是真心看不起世界上的通用标准，谁他妈就规定了做人就一定要和群,做人就一定要跟一堆人玩才开心,老子就喜欢潜心创作，程序就是我最好的表达方式。这其中爆发出来的能量就是感觉不一样,关于艺术的表达，思维的进步绝对不是学习和分享可以推进的,相反反思，拒绝，否认的态度更容易推进思维以一种两面性的维度发展。   </p>
<p>回头看看自己的二十年生活,一直活在别人的标准里。心里老早就有了厌恶感，却迟迟没有做出改变。社交网络的发展让富人阶级的生活暴露在大众面前,现行社会的畸态就是由这些无谓的阶级比较导致的。社会的通用标准也变成了攀爬，穷人变中产，中产变富人。若能越级跳跃，拿出来就又是一个励志故事。如果读书读到最后生活过得还不好，就成了读死书的反面代表。提倡和鼓励的不是为自己而活，表面上美其名曰不为父母而活，实际里却是为标准而活。幽默的是，敢爱敢恨，敢想敢做难道不也是一种标准?不过都是不上台面的标准,真正的标准是为社会团里利益而服务，好比一台运转良好的机器，什么样的固件最好用？就像中软一位老师的一句话一样,“将最聪明的学生变成标准件”。看到这里是不是又觉得很忧伤？别紧张，我换个角度来看你看法就又变了，灵活多变是热火，标准化是马刺，您支持谁？您会说这是两种不同的篮球文化，都应该受到尊重？那么社会的文化又岂只有两种，我们应该怎样选择？  </p>
<p>感觉最后好像说明白了。本文并不是为了批判当下标准多丑陋,而是为了提醒自己尊重别人标准，但是也要坚持自己的标准。  </p>
<p>多么希望很多年后有人问我:&quot;是什么让你一直坚持下去?&quot;   </p>
<p>我能够回答  </p>
<p>&quot;是厌恶&quot;</p>
]]></content>
    <category scheme="http://shujian.me//tags/life/" term="life"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[wwdc后记]]></title>
    <link href="http://shujian.me//2013/06/11/talk-about-wwdc/"/>
    <id>http://shujian.me//2013/06/11/talk-about-wwdc/</id>
    <published>2013-06-10T16:00:00.000Z</published>
    <updated>2013-08-01T05:25:02.115Z</updated>
    <content type="html"><![CDATA[<p>APPLE的战略非常正确，从硬体公司到软体公司的改变是非常必要的（反观NOKIA，也做软体，但是骨子里还是硬体公司).<br>整个发布会也是亮点多多：</p>
<ol>
<li>os mavericks中finder tags,tags,notification,multiple display,energy saving,new map new calender,social media integration都进一步提升用户体验，全是加分项。</li>
<li>mac pro就不吐槽了，整个一饭桶造型，沃兹都逗乐呵了。</li>
<li>IOS7必须是我喜欢的设计，Flat Design、3D透明、Chromatic它都占全了，可能男的觉得太鲜艳了，是给12岁的女孩设计的。但是我依然觉得这是整个发布会最惊艳的地方，特别是在与ive低音炮一样的性感声音出场的时候。内部一些细节提升的东西也很有很多，Control Center又让人们少了个越狱理由，Camera又少了个用第三方应用的理由，Safari升级更加纯粹了，AirDrop和new APPStore都是好东西。比较值得一提的是Find my iphone的远程加锁和ios in the car，这个明显是以后的趋势，通过Siri跟汽车的整合，我会说我爸现在开车就是用andriod接个汽车里面带的软件，体验烂的一比吗？</li>
<li>价格倒是11寸好像降低了，我刚才看的时候用港版选13 128GB的用教育优惠升级到i7和8gb ram也才9,882港币，人民币就7800多，日元也是126,990，人民币7800多，过几天就看看哪家代购更给力。</li>
<li>最后在赞一个john ive,这flat design的功力比微软不知道强到哪里去了。。。  看过wp8原版界面就知道丑的啥样了，ios只是一个接受的时间问题，就像ios6一样，最终最少90%的用户都会升级，就算不升级，p大出个ios7 perfect jail breaking包。。然后都升了。。</li>
</ol>
]]></content>
    <category scheme="http://shujian.me//tags/apple/" term="apple"/>
    <category scheme="http://shujian.me//tags/wwdc/" term="wwdc"/>
    <category scheme="http://shujian.me//tags/Mac-OS-X/" term="Mac OS X"/>
    <category scheme="http://shujian.me//tags/IOS/" term="IOS"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[趁复习备考之际记录一些关于C语言进程通信的东东]]></title>
    <link href="http://shujian.me//2013/06/08/something-about-process-comunication-in-c/"/>
    <id>http://shujian.me//2013/06/08/something-about-process-comunication-in-c/</id>
    <published>2013-06-07T16:00:00.000Z</published>
    <updated>2013-08-01T05:25:19.799Z</updated>
    <content type="html"><![CDATA[<p>过两天就要考linux了啦,所以这几天在集中精力复习linux,其实课程讲的比较简单,PPT前几章都没什么好玩的,就最后3章开始介绍文件系统和进程通信的时候才有大量编程的部分,当然这才是最有意思的部分.</p>
<h2>基本概念</h2>
<p>通信分两类:  </p>
<ul>
<li>控制信息的传递:低级通信</li>
<li>大批量数据的传递:高级通信</li>
</ul>
<p>基本的通信方式有:</p>
<ul>
<li>主从式通信(通信双方存在一种隶属关系,特点在于通信过程中主进程对从进程的资源和数据享有使用权限，但是从进程没有)</li>
<li>会话式通信(通信进程双方采用请求应答的方式进行通信,特点在于通信时使用者进程需要事先得到服务者进程的允许，方能使用服务者进程为其提供的服务)</li>
<li>消息或邮件通信(通信双方处于一个平等地位，在通信过程中无论接收进程是否准备好，发送进程都可以进行消息发送,特点在于发送进程和接收进程之间不需要建立直接的逻辑关联关系)</li>
<li>共享存储区通信(进程之间采用信息共享存储区的通信方式来完成进程间的通信,特点在于通信进程双方通过一个共享存储区完成信息交互)</li>
</ul>
<p><code>unix</code>系统主要采用三种通信方式:</p>
<ul>
<li>基本通信：早期的UNIX系统采用，简单的信息传递，协调进程之间的同步和互斥(包括锁文件通信、记录锁定文件通信、信号三种方式)。</li>
<li>管道通信：大批量的数据传送，有名管道和无名管道。</li>
<li>IPC ：采用消息方式进行进程间通信。 </li>
</ul>
<p>信号是进程中异步发生事件时发出的提示信息或传送给进程的一种事件通知，是UNIX操作系统用来通知进程发生了某种事件的一种手段。信号可以由用户进程或核心进程发出，提请系统立即将当前进程中已发生的时间想相关进程进行通告。信号提供了一种处理异步事件的方法。信号也可以用于进程之间进行通信和实现进程同步处理。生成信号的事件可以归并为三大类:</p>
<ul>
<li>程序错误  例如零作除数、非法存储器访问等</li>
<li>外部事件 例如用户按下Delete键、定时器到期等</li>
<li>显式请求 进程主动调用kill函数或者raise函数</li>
</ul>
<p><a name="more"></a>
UNIX系统为每一种可能的事件定义了一组信号，每一个信号有一个信号名，名字均以SIG打头，UNIX系统中常用的信号: </p>
<table >
    <tr>
        <td>&#20449;&#21495;</td>
        <td>&#25551;&#36848;</td>
        <td>&#40664;&#35748;&#22788;&#29702;</td>
    </tr>
    <tr>
        <td>SIGABRT</td>
        <td>&#36827;&#31243;&#24322;&#24120;&#20013;&#27490;&#65292;&#35843;&#29992;abort&#20989;&#25968;&#29983;&#25104;&#35813;&#20449;&#21495;</td>
        <td>&#24322;&#24120;&#20013;&#27490;</td>
    </tr>
    <tr>
        <td>SIGALRM</td>
        <td>&#23454;&#26102;&#38393;&#38047;</td>
        <td>&#36827;&#31243;&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGFPE</td>
        <td>&#31639;&#26415;&#20363;&#22806;</td>
        <td>&#24322;&#24120;&#20013;&#27490;</td>
    </tr>
    <tr>
        <td>SIGHUP</td>
        <td>&#25346;&#36215;&#36827;&#31243;</td>
        <td>&#36827;&#31243;&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGILL</td>
        <td>&#38750;&#27861;&#30828;&#20214;&#25351;&#20196;</td>
        <td>&#24322;&#24120;&#32456;&#27490;</td>
    </tr>
    <tr>
        <td>SIGKILL</td>
        <td>&#32456;&#27490;&#36827;&#31243;</td>
        <td>&#36827;&#31243;&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGPIPE</td>
        <td>&#20889;&#27809;&#26377;&#35835;&#32773;&#30340;&#31649;&#36947;</td>
        <td>&#36827;&#31243;&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGQUIT</td>
        <td>&#32456;&#31471;quit&#23383;&#31526; &#65288;ctrl-\&#65289;</td>
        <td>&#24322;&#24120;&#32456;&#27490;</td>
    </tr>
    <tr>
        <td>SIGSEGV</td>
        <td>&#38750;&#27861;&#23384;&#20648;&#35775;&#38382;&#65288;&#22320;&#22336;&#36234;&#30028;&#65289;</td>
        <td>&#24322;&#24120;&#32456;&#27490;</td>
    </tr>
    <tr>
        <td>SIGTERM</td>
        <td>&#32456;&#27490;&#36827;&#31243;</td>
        <td>&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGTRAP</td>
        <td>&#30828;&#20214;&#33258;&#38519;</td>
        <td>&#24322;&#24120;&#32456;&#27490;</td>
    </tr>
    <tr>
        <td>SIGUSR1</td>
        <td>&#29992;&#25143;&#33258;&#23450;&#20041;&#20449;&#21495;</td>
        <td>&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGUSR2</td>
        <td>&#29992;&#25143;&#33258;&#23450;&#20041;&#20449;&#21495;</td>
        <td>&#36864;&#20986;</td>
    </tr>
    <tr>
        <td>SIGSTOP</td>
        <td>&#20572;&#27490;&#36827;&#31243;</td>
        <td>&#36864;&#20986;</td>
    </tr>
</table>

<p>信号的产生，可以使用三个系统调用:</p>
<ul>
<li>int raise( int sig );   &gt;  给进程自己发送一个信号</li>
<li>int kill( pid_t pid,  int sig );   &gt;  发送一个信号给进程或者进程组</li>
<li>unisigned int  alarm( unsigned int seconds );   &gt;  在seconds秒后向自己发送一个SIGALRM信号</li>
</ul>
<p>下面是一个关于kill调用的实例:</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="code"><pre><span class="comment">#include "unistd.h"</span>
<span class="comment">#include "signal.h"</span>
<span class="comment">#include "sys/types.h"</span>
<span class="comment">#include "sys/wait.h"</span>
<span class="comment">#include "stdio.h"</span>

<span class="title">int</span> main ( int argc, char const *argv[] ) {
    <span class="title">pid_t</span> pid;
    <span class="title">int</span> status;

    <span class="title">if</span> ( ! ( pid = fork() ) ) {
        <span class="title">printf</span> ( <span class="string">"Hi I am child process!\n"</span> );
        <span class="title">printf</span> ( <span class="string">"My pid is %d\n"</span>, getpid() );
        <span class="title">sleep</span> ( <span class="number">100</span> );
        <span class="title">return</span> <span class="number">0</span>;
    } <span class="title">else</span> {
        <span class="title">printf</span> ( <span class="string">"send signal to child process(%d)\n"</span>, pid );
        <span class="title">sleep</span> ( <span class="number">1</span> );
        <span class="title">kill</span> ( pid, SIGKILL );
        <span class="title">wait</span> ( &status );

        <span class="title">if</span> ( WIFSIGNALED ( status ) )
            printf ( <span class="string">"chile process receive signal %d\n"</span>, WTERMSIG ( status ) );
    }

    <span class="title">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>子进程的结束状态返回后存于status，底下有几个宏可判别结束情况:</p>
<ul>
<li>WIFEXITED(status):如果子进程正常结束则为非0值</li>
<li>WEXITSTATUS(status):取得子进程exit()返回的结束代码，一般会先用WIFEXITED 来判断是否正常结束才能使用此宏</li>
<li>WIFSIGNALED(status):如果子进程是因为信号而结束则此宏值为真</li>
<li>WTERMSIG(status):取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED 来判断后才使用此宏</li>
<li>WIFSTOPPED(status):如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况</li>
<li>WSTOPSIG(status):取得引发子进程暂停的信号代码</li>
</ul>
<p><img src="http://sergio-blog.qiniudn.com/kill_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt="程序运行结果"></p>
<p>alarm调用实例:</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="preprocessor">#include "unistd.h"</span>
<span class="preprocessor">#include "signal.h"</span>
<span class="preprocessor">#include "stdio.h"</span>
<span class="keyword">void</span> handler ( <span class="keyword">int</span> a ) {
    printf ( <span class="string">"hello\n"</span> );
}
<span class="keyword">int</span> main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[] ) {
    <span class="keyword">int</span> i;
    <span class="keyword">signal</span> ( SIGALRM,  handler );
    alarm ( <span class="number">5</span> );

    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i ) {
        printf ( <span class="string">"sleep %d ... \n"</span>, i );
        sleep ( <span class="number">1</span> );
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p><img src="http://sergio-blog.qiniudn.com/alarm_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<p>实际上信号名都可以使用<code>kill -l</code>命令查询到
<img src="http://sergio-blog.qiniudn.com/kill-l-instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<p>下面是用<code>void* signal(int sig , void(* func )(int ))</code>函数捕获SIGINT信号的例子(在<code>Terminal</code>中通过按下<code>Ctrl+C</code>产生):</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="preprocessor">#include "signal.h"</span>
<span class="preprocessor">#include "stdio.h"</span>
<span class="preprocessor">#include "unistd.h"</span>
<span class="keyword">void</span> catch_sig_int ( <span class="keyword">int</span> signo ) {
    <span class="comment">/* signal (SIGINT, catch_sig_int); */</span>
    printf ( <span class="string">"SIGINT was caught,user pressed key[delete]\n"</span> );
    <span class="comment">/* signal (SIGINT, catch_sig_int); */</span>
}
<span class="keyword">int</span> main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[] ) {
    <span class="keyword">int</span> i = <span class="number">0</span>;
    <span class="keyword">signal</span> ( SIGINT, catch_sig_int );

    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i ) {
        printf ( <span class="string">"Sleep called  #%d\n"</span>, i );
        sleep ( <span class="number">1</span> );
    }

    printf ( <span class="string">"exiting ...\n"</span> );
    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>运行结果如下图:
<img src="http://sergio-blog.qiniudn.com/signal_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<p>下面是关于自定义信号的使用的例子:</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">#include "signal.h"</span>
<span class="comment">#include "stdio.h"</span>
<span class="comment">#include "unistd.h"</span>
<span class="comment">#include "signal.h"</span>
<span class="comment">#include "stdlib.h"</span>
void signal_handle ( <span class="keyword">int</span> the_signal ) {
    <span class="keyword">if</span> ( the_signal == SIGUSR1 )
        <span class="keyword">printf</span> ( <span class="string">"the signal is SIGUSR1\n"</span> );
    <span class="keyword">else</span> <span class="keyword">if</span> ( the_signal == SIGUSR2 )
        <span class="keyword">printf</span> ( <span class="string">"the signal is SIGUSR2\n"</span> );
    <span class="keyword">else</span>
        <span class="keyword">printf</span> ( <span class="string">"the received signal is <span class="variable">%d</span>\n"</span>, the_signal );
}
<span class="keyword">int</span> main ( <span class="keyword">int</span> argc, char const <span class="variable">*argv</span>[] ) {
    <span class="keyword">printf</span> ( <span class="string">"the process id is <span class="variable">%d</span>\n"</span>, getpid() );

    <span class="keyword">if</span> ( signal ( SIGUSR1, signal_handle ) == SIG_ERR ) {
        <span class="keyword">printf</span> ( <span class="string">"Error occurs!\n"</span> );
        <span class="keyword">exit</span> ( <span class="number">1</span> );
    }

    <span class="keyword">if</span> ( signal ( SIGUSR2, signal_handle ) == SIG_ERR ) {
        <span class="keyword">printf</span> ( <span class="string">"Error occurs!\n"</span> );
        <span class="keyword">exit</span> ( <span class="number">1</span> );
    }

    <span class="keyword">for</span> ( ; ; ) {
        pause(); <span class="regexp">//pause</span>()函数等待信号到来
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>程序运行结果:
<img src="http://sergio-blog.qiniudn.com/signal_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<h2>管道通信</h2>
<p>UNIX中的管道用于进程通信,是一种先进先出（FIFO）的特殊文件,通常是一个进程向管道中写入数据，另一个进程从管道中读出数据,从而完成通信的目的.</p>
<p>管道的特点:</p>
<ul>
<li>管道单独构成一种特殊的文件</li>
<li>管道中，写入的内容每次都添加在管道的末尾，并且每次都是从管道的头部读出数据，就像队列</li>
</ul>
<p>无名管道一般通过以下三个函数操作:</p>
<ul>
<li>int pipe( int fdes[2] )</li>
<li>int read( int fd, char *buf, int len );</li>
<li>int write( int fd, char *buf, int len );</li>
</ul>
<p>下面是最简单的管道通信的一个例子:</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="comment">#include &lt;unistd.h&gt;</span>
<span class="comment">#include &lt;stdlib.h&gt;</span>
<span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#include "sys/wait.h"</span>

<span class="keyword">int</span> main() {
    <span class="keyword">int</span> pipe_fd[<span class="number">2</span>];  <span class="regexp">//define</span> <span class="keyword">pipe</span><span class="string">'s in and out, there is a int array
    pid_t child;
    char buf_r[100];
    char *p_buf;
    int r_num;

    if ( pipe ( pipe_fd ) &lt; 0 ) {
        printf ( "pipe create error !\n" );
        exit ( -1 );
    } else {
        printf ( "pipe create success !\n" );
    }

    if ( ( child = fork() ) == 0 ) {
        // child process coming
        printf ( "\n" );
        close ( pipe_fd[1] ); //close father'</span><span class="keyword">s</span> <span class="keyword">write</span> <span class="keyword">pipe</span>
        <span class="keyword">sleep</span> ( <span class="number">2</span> );

        <span class="keyword">if</span> ( ( r_num = <span class="keyword">read</span> ( pipe_fd[<span class="number">0</span>], buf_r, <span class="number">100</span> ) ) &gt; <span class="number">0</span> ) {
            <span class="keyword">printf</span> ( <span class="string">"<span class="variable">%d</span> numbers read from the pipe is <span class="variable">%s</span> \n"</span>, r_num, buf_r );
        }

        <span class="keyword">close</span> ( pipe_fd[<span class="number">0</span>] ); <span class="regexp">//</span> <span class="keyword">close</span> <span class="keyword">read</span> <span class="keyword">pipe</span>
        <span class="keyword">exit</span> ( <span class="number">0</span> );
    } <span class="keyword">else</span> <span class="keyword">if</span> ( child &gt; <span class="number">0</span> ) {
        <span class="keyword">printf</span> ( <span class="string">"child=<span class="variable">%d</span> \n"</span>, child );
        <span class="keyword">printf</span> ( <span class="string">"father pid= <span class="variable">%d</span> \n"</span>, getpid() );
        <span class="keyword">close</span> ( pipe_fd[<span class="number">0</span>] ); <span class="regexp">//close</span> child<span class="string">'s read pipe

        if ( write ( pipe_fd[1], "hello", 5 ) != -1 )
            printf ( "parent write1 hello !\n" );

        if ( write ( pipe_fd[1], "HELLO", 5 ) != -1 )
            printf ( "parent write2 HELLO ! \n" );

        close ( pipe_fd[1] ); // close farther'</span><span class="keyword">s</span> <span class="keyword">write</span>
        <span class="keyword">waitpid</span> ( child, NULL, <span class="number">0</span> ); <span class="regexp">//wait</span> child to release resource
        <span class="keyword">return</span> <span class="number">0</span>;
    }
}
</pre></td></tr></table></figure>

<p>程序运行结果(最下面有个EOF乱码问题,暂时还不知道如何解决)：
<img src="http://sergio-blog.qiniudn.com/pipe_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<p>另一种方式是有名管道:</p>
<table >
   <tr>
      <td>&#29305;&#24615;</td>
      <td>&#26377;&#21517;&#31649;&#36947;</td>
      <td>&#26080;&#21517;&#31649;&#36947;</td>
   </tr>
   <tr>
      <td>&#36827;&#31243;&#30340;&#20351;&#29992;&#36164;&#26684;</td>
      <td>&#27809;&#26377;&#38480;&#21046;</td>
      <td>&#24517;&#39035;&#26377;&#29238;&#23376;&#20851;&#31995;</td>
   </tr>
   <tr>
      <td>&#25991;&#20214;&#21517;&#31216;</td>
      <td>&#26377;&#25991;&#20214;&#21517;&#65292;&#21487;&#20197;&#29992;ls –l&#26597;&#30475;&#65292;&#20854;&#25991;&#20214;&#23646;&#24615;&#20026;p</td>
      <td>&#27809;&#26377;&#25991;&#20214;&#21517;&#31216;</td>
   </tr>
   <tr>
      <td>&#25968;&#25454;&#35835;&#20889;&#30340;&#27425;&#24207;</td>
      <td>&#20808;&#36827;&#20808;&#20986;</td>
      <td>&#20808;&#36827;&#20808;&#20986;</td>
   </tr>
   <tr>
      <td>&#24314;&#31435;&#30340;&#26041;&#24335;</td>
      <td>&#20351;&#29992;mkfifo&#25110;&#32773;mknod&#20989;&#25968;</td>
      <td>&#20351;&#29992;pipe&#20989;&#25968;</td>
   </tr>
   <tr>
      <td>&#21024;&#38500;&#30340;&#26041;&#24335;</td>
      <td>&#20351;&#29992;rm&#21629;&#20196;&#25110;&#32773;unlink&#20989;&#25968;</td>
      <td>&#34987;&#20351;&#29992;&#23436;&#21518;&#65292;&#20250;&#34987;&#33258;&#21160;&#21024;&#38500;</td>
   </tr>
</table>

<p>通常使用的有名管道相关函数有：</p>
<ul>
<li>int mkfifo( char *path, mode_t mode );</li>
<li>int mknod( char *path, mode_t mode, dev_t dev );</li>
<li>int mkfifo( “/home/user1/myfifo”, 0666 );</li>
<li>int mknod( “/home/user1/myfifo”, 0666|S_IFIFO, 0);</li>
<li>int open(const char* filename,int flags[,mode_t mode]);</li>
<li>int read( int fd, char *buf, int len );</li>
<li>int write( int fd, char *buf, int len );</li>
<li>int close (int fd);</li>
</ul>
<h2>IPC</h2>
<p>在IPC (Interprocess communication)的通信模式通常有三种：消息队列、信号量、共享内存。</p>
<ul>
<li>消息队列方式：使用一个消息结构完成进程间分类格式化数据的传送</li>
<li>共享存储区方式：允许进程间共享 虚地址空间的某些区域，以达到信息传送的效果</li>
<li>信号量方式：允许进程在一组信号量上进行交互，完成同步地执行</li>
</ul>
<p>以下是信号与消息的比较:</p>
<table >
   <tr>
      <td>&#29305;&#24615;</td>
      <td>&#20449;&#21495;</td>
      <td>&#28040;&#24687;</td>
   </tr>
   <tr>
      <td>&#25968;&#25454;&#20869;&#23481;</td>
      <td>&#21482;&#26159;&#19968;&#20123;&#39044;&#35774;&#22909;&#30340;&#20195;&#30721;&#29992;&#20197;&#34920;&#31034;&#31995;&#32479;&#21457;&#29983;&#30340;&#26576;&#20123;&#29366;&#20917;</td>
      <td>&#20026;&#19968;&#32452;&#36830;&#32493;&#35821;&#21477;&#25110;&#32773;&#31526;&#21495;&#65292;&#36890;&#24120;&#37327;&#19981;&#20250;&#22826;&#22823;(&#27604;&#22914;1024&#23383;&#33410;)</td>
   </tr>
   <tr>
      <td>&#29992;&#36884;</td>
      <td>&#25285;&#20219;&#36827;&#31243;&#38388;&#23569;&#37327;&#20449;&#24687;&#30340;&#20256;&#36865;&#65292;&#22810;&#21322;&#26159;&#26680;&#24515;&#31243;&#24207;&#29992;&#26469;&#36890;&#30693;&#29992;&#25143;&#36827;&#31243;&#19968;&#20123;&#24322;&#24120;&#30340;&#29366;&#20917;</td>
      <td>&#29992;&#20110;&#36827;&#31243;&#20043;&#38388;&#24444;&#27492;&#36827;&#34892;&#25968;&#25454;&#20132;&#25442;</td>
   </tr>
   <tr>
      <td>&#21457;&#36865;&#26102;&#21051;</td>
      <td>&#20219;&#20309;&#26102;&#38388;</td>
      <td>&#19981;&#26159;&#20219;&#20309;&#26102;&#21051;&#37117;&#21487;&#20197;&#21457;&#36865;</td>
   </tr>
   <tr>
      <td>&#21457;&#36865;&#32773;&#36776;&#35782;</td>
      <td>&#19981;&#30693;&#36947;&#21457;&#36865;&#32773;&#26159;&#35841;</td>
      <td>&#26126;&#30830;&#30693;&#36947;&#21457;&#36865;&#32773;&#26159;&#35841;</td>
   </tr>
   <tr>
      <td>&#36865;&#24448;&#23545;&#35937;</td>
      <td>&#26576;&#20010;&#36827;&#31243;</td>
      <td>&#28040;&#24687;&#38431;&#21015;</td>
   </tr>
   <tr>
      <td>&#22788;&#29702;&#26041;&#27861;</td>
      <td>&#21487;&#20197;&#22788;&#29702;&#25110;&#32773;&#19981;&#20104;&#29702;&#20250;</td>
      <td>&#24517;&#39035;&#35201;&#22788;&#29702;</td>
   </tr>
   <tr>
      <td>&#25968;&#25454;&#20256;&#36755;&#25928;&#29575;</td>
      <td>&#19981;&#36866;&#21512;&#36739;&#22823;&#37327;&#30340;&#20449;&#24687;&#20256;&#36755;&#65292;&#25928;&#29575;&#24046;</td>
      <td>&#23545;&#20013;&#31561;&#25968;&#37327;&#30340;&#25968;&#25454;&#20256;&#36865;&#25928;&#29575;&#22909;</td>
   </tr>
</table>

<p>消息的接受需要用到函数<code>msgrcv</code>,消息队列的控制需要用到函数<code>msgctl</code><br>下面是一段进程间通信的例子</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
</pre></td><td class="code"><pre><span class="comment">/**
program1.c 
recieve text from program2.c 's instance
have fun !
**/</span>

<span class="preprocessor">#include "sys/types.h"</span>
<span class="preprocessor">#include "sys/ipc.h"</span>
<span class="preprocessor">#include "sys/msg.h"</span>
<span class="preprocessor">#include "stdio.h"</span>
<span class="preprocessor">#include "string.h"</span>
<span class="preprocessor">#include "stdlib.h"</span>

<span class="keyword">struct</span>  my_msg {
    <span class="keyword">long</span> mytype;
    <span class="keyword">char</span> text[<span class="number">256</span>];
};
<span class="keyword">int</span> main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[] ) {
    <span class="keyword">int</span> running  = <span class="number">1</span>;
    <span class="keyword">int</span> msgid;
    <span class="keyword">struct</span> my_msg msgbuf;
    msgid = msgget ( ( key_t ) <span class="number">1234</span>,<span class="constant"> IPC_CREAT </span>| <span class="number">0666</span> );

    if ( msgid &lt; <span class="number">0</span> )
        exit ( <span class="number">1</span> );

    <span class="keyword">while</span> ( running ) {
        if (msgrcv ( msgid , ( <span class="keyword">void</span> * ) &msgbuf, <span class="number">256</span>, <span class="number">1</span>, <span class="number">0</span> ) ) {
            <span class="comment">// deal with error occur</span>
            printf ( <span class="string">"you wrote : %s \n"</span>, msgbuf.text );
        }

        if ( strncmp ( msgbuf.text , <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) {
            running = <span class="number">0</span>;
        }
    }

    if ( msgctl ( msgid, IPC_RMID, <span class="number">0</span> ) == -<span class="number">1</span> ) {
        <span class="comment">// deal with error occur</span>
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}


<span class="comment">/**
program2.c 
send text to program1.c 's instance
have fun !
**/</span>

<span class="preprocessor">#include "sys/types.h"</span>
<span class="preprocessor">#include "sys/ipc.h"</span>
<span class="preprocessor">#include "sys/msg.h"</span>
<span class="preprocessor">#include "stdio.h"</span>
<span class="preprocessor">#include "string.h"</span>
<span class="preprocessor">#include "stdlib.h"</span>

<span class="keyword">struct</span>  my_msg {
    <span class="keyword">long</span> mytype;
    <span class="keyword">char</span> text[<span class="number">256</span>];
};
<span class="keyword">int</span> main ( <span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[] ) {
    <span class="keyword">int</span> running  = <span class="number">1</span>;
    <span class="keyword">int</span> msgid;
    <span class="keyword">struct</span> my_msg msgbuf;
    msgid = msgget ( ( key_t ) <span class="number">1234</span>,<span class="constant"> IPC_CREAT </span>| <span class="number">0666</span> );

    if ( msgid &lt; <span class="number">0</span> )
        exit ( <span class="number">1</span> );

    <span class="keyword">while</span> ( running ) {
        printf ( <span class="string">"Enter some text :"</span> );
        gets ( msgbuf .text );
        msgbuf.mytype = <span class="number">1</span>;

        if (  msgsnd ( msgid, ( <span class="keyword">void</span> * ) &msgbuf, <span class="number">256</span>, <span class="number">0</span> ) == -<span class="number">1</span> ) {
            <span class="comment">// deal with error occurs</span>
        }

        if ( strncmp ( msgbuf.text, <span class="string">"end"</span>, <span class="number">3</span> ) == <span class="number">0</span> ) {
            running = <span class="number">0</span>;
        }
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</pre></td></tr></table></figure>

<p>程序运行结果如下:
<img src="http://sergio-blog.qiniudn.com/ipc_instance.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
]]></content>
    <category scheme="http://shujian.me//tags/c-1/" term="c"/>
    <category scheme="http://shujian.me//tags/IPC/" term="IPC"/>
    <category scheme="http://shujian.me//tags/Process-Comunication/" term="Process Comunication"/>
    <category scheme="http://shujian.me//tags/linux/" term="linux"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[聊聊我的Jekyll Blog是如何建立的]]></title>
    <link href="http://shujian.me//2013/06/06/talk-about-myblog/"/>
    <id>http://shujian.me//2013/06/06/talk-about-myblog/</id>
    <published>2013-06-05T16:00:00.000Z</published>
    <updated>2013-08-01T05:25:09.051Z</updated>
    <content type="html"><![CDATA[<p>在网上写Blog也有快2年时间了,中间换过不少的产品,从早期的QQ空间,到后来的Wordpress,再到现在开始使用Jekyll并逐渐稳定下来。Jekyll是一个非常简洁的Blog静态页面生成器(Static Site Generators),采用<code>Git</code>管理和用<code>Markdown</code>进行写作并且能够通过<code>Github Pages</code>免费快速部署的特性让其变得流行,当然在这里我并不打算讲解一些Jekyll的原理,也不会讲解一些Jekyll的入门,这些介绍在网上实在太多太多了,比如:</p>
<ul>
<li><a href="http://www.soimort.org/posts/101/">像黑客一样写Blog</a></li>
<li><a href="http://mkaito.github.io/2010/why-jekyll.html">Why Jekyll</a></li>
<li><a href="http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html">Blogging Like a Hacker</a></li>
</ul>
<p>我只打算介绍下Jekyll Theme的选择,我所使用的Jekyll配置和第三方Web服务</p>
<h2>Jekyll Theme</h2>
<ul>
<li>在Blog的Footer部分我已经标注,本Blog theme drived from <a href="http://lhzhang.com/">sext v</a>,个人加了很多的修改,比如整体的配色,相关插件的选择,最终才成型到现在的模样.个人觉得使用Jekyll最好的地方就在于可以很方便的用HTML5和Javascript在前端实现自己的效果,但是作为Blog，整体的设计重点应该Focus在文字的阅读之上，所以我更加偏向于采用简洁的设计。</li>
<li>新手可以选择<code>Jekyll Bootstrap</code></li>
</ul>
<p><a name="more"></a></p>
<h2>Plugins</h2>
<ul>
<li>代码Highlight部分我并没有采用<code>Pygements</code>,也没有采用网上流行的<code>Hignlight.js</code>,为了配合整体网站风格，单独使用品红的配色展现出来的色彩效果已经足够简洁优异.</li>
<li>遵从潮流使用<code>Disqus</code>做评论系统,_config.yml中使用<code>redcarpet</code>做Markdown解析引擎,从而支持GFM(Github Flavored Markdown)的语法</li>
</ul>
<h2>Third party service</h2>
<ul>
<li>网站统计上使用的是<a href="https://www.woopra.com/">Woopra</a>,感觉比Google Analytics或者国内的腾讯、百度之类的站长统计优异很多,界面非常漂亮现代化，而且可以支持实时检测，还可以在线跟网站访问者聊天，自定义Trigger和Report等功能监控网站.</li>
<li>使用国产免费<a href="https://www.dnspod.cn/">Dnspod</a>做DNS解析,并使用其相关的服务器监控技术</li>
<li>同时也使用了<a href="http://www.incapsula.com/">Incapsula</a>进行免费的全球CDN加速</li>
</ul>
<h2>further developing</h2>
<p>Jeykll最致命的问题在于没有很好的搜索功能,不过网上已经有篇帖子说如何做<a href="http://justjavac.com/jekyll/2012/03/04/static-search-article-on-jekyll.html">静态搜索</a>,这也是我最近一段时间想要完成的。</p>
]]></content>
    <category scheme="http://shujian.me//tags/jekyll/" term="jekyll"/>
    <category scheme="http://shujian.me//tags/blog/" term="blog"/>
    <category scheme="http://shujian.me//tags/woopra/" term="woopra"/>
    <category scheme="http://shujian.me//tags/incapsula/" term="incapsula"/>
    <category scheme="http://shujian.me//tags/github-page/" term="github page"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[ruby2.0+rails4.0环境配置]]></title>
    <link href="http://shujian.me//2013/06/04/rails4/"/>
    <id>http://shujian.me//2013/06/04/rails4/</id>
    <published>2013-06-03T16:00:00.000Z</published>
    <updated>2013-08-01T05:25:24.495Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>风格是从伟大事物中萃取出的美好事物。 ---  Bozhidar Batsov</p>
</blockquote>
<p>最近开始学习ruby on rails，网上一搜发现ruby现在最新是2.0，rails是4.0rc，废话不多说，开始搭环境。<br>个人环境:<code>linuxmint 15</code>，安装过程遵循一下步骤:<br>1. 安装<code>RVM</code>
2. 安装<code>Ruby2.0</code>
3. 通过<code>Gem</code>安装<code>Rails4.0rc</code></p>
<h2>RVM</h2>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>$ curl -L get.rvm.io | bash -s stable
$ source ~/.bashrc
$ source ~/.bash_profile
</pre></td></tr></table></figure>

<ul>
<li>修改 RVM 的 Ruby 安装源到国内的 淘宝镜像服务器，这样能提高安装速度:  </li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ sed -i -e <span class="string">'s/ftp\.ruby-lang\.org\/pub\/ruby/ruby\.taobao\.org\/mirrors\/ruby/g'</span> ~/.rvm/config/db
</pre></td></tr></table></figure>

<h2>Ruby的安装与切换</h2>
<ul>
<li>列出已知的ruby版本</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>rvm list known
</pre></td></tr></table></figure>

<ul>
<li>安装一个ruby版本</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>rvm install 2.0.0
</pre></td></tr></table></figure>

<ul>
<li>使用一个ruby版本</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>rvm use 2.0.0
</pre></td></tr></table></figure>

<ul>
<li>查询已经安装的ruby</li>
</ul>
<p><a name="more"></a></p>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>rvm list
</pre></td></tr></table></figure>

<ul>
<li>卸载一个已安装版本</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>rvm remove 2.0.0
</pre></td></tr></table></figure>

<ul>
<li>注意，在ubuntu下要做一点另外的设置</li>
</ul>
<p><img src="http://sergio-blog.qiniudn.com/rvm_ubuntu.jpg?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
<h2>Rails4.0的安装</h2>
<ul>
<li>直接使用<code>Gem</code>安装Rails4.0rc</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ gem install install rails --version 4.0.0.rc1 --no-ri --no-rdoc
</pre></td></tr></table></figure>

<ul>
<li>然后新建一个项目</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ rails new demo
</pre></td></tr></table></figure>

<ul>
<li>进入项目目录，然后查看rails版本号(这步只是告诉你，你还有很多依赖没安装)</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="comment">$</span> <span class="comment">rails</span> <span class="literal">-</span><span class="comment">v
</pre></td></tr></table></figure>

<ul>
<li>安装完依赖就可以启动服务器啦</li>
</ul>
<figure class="highlight lang-bash"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ rails server
</pre></td></tr></table></figure>

<ul>
<li>最后通过<code>localhost:3000</code>访问就可以看到以下画面啦(结束了噢!)</li>
</ul>
<p><img src="http://sergio-blog.qiniudn.com/ror.png?imageMogr/auto-orient/thumbnail/686/quality/100/format/PNG" alt=""></p>
]]></content>
    <category scheme="http://shujian.me//tags/ruby/" term="ruby"/>
    <category scheme="http://shujian.me//tags/rails/" term="rails"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[妙峰山下]]></title>
    <link href="http://shujian.me//2013/01/28/miaofengshan/"/>
    <id>http://shujian.me//2013/01/28/miaofengshan/</id>
    <published>2013-01-27T16:00:00.000Z</published>
    <updated>2013-08-01T05:25:30.035Z</updated>
    <content type="html"><![CDATA[<p>壬辰龙年，腊月十七，北京妙峰山下，晴，大雾。缘由心生，缘起缘落，世间事大都绕不过一个“缘”字。</p>
<p>这是在北京的第五天，每天早出晚归，凭一口杯、一红书、一笔电，驰骋在杀鸡的第一线。从mediocre的乔淼，到astounding的宁立波，再到comfortable的刘之元，课程风格的变化还是比较让人欣喜，当然槽点最多还是波波叔叔，“太优秀了，人就这么优秀，没法弄!”。乔淼还是有点学生或者说是不熟练的感觉，站在讲台上对整体氛围的掌控还是达不到Hold住的地步，波波叔叔就是在带节奏了，由于我没有上过他的强化班的课程，直接上他第一精讲精练的课程的时候真是各种不适应，对他说的一些模式都听得云里雾里，完全跟葛亮/徐亮那套方法论不同，他更加集中与一些句式的变化、遣词造句的功底、押韵的考虑，在第一次的课中还大秀他的修改句子的能力，以至于我在后来的时间里最期待的就是他的课程。当然今天也上了他的课程，全程充满欢乐，他也透露了一些他的人生感悟和与一些名人诸如范冰冰、撒贝宁的轶事，再结合他学哲学的北京，觉得波波老师还是很牛气的。刘之元老师的课程代入感会比较好，相比前两个老师有个承上啓下的过程，然后给了很多留学的建议，分享了一些他的一些往事，课程教学上第一节课程主要是词汇串讲，更深的功力还等待下节课进一步证明。</p>
<p>新东方这里条件还是比我想象中好很多，暖气相当给力，寝室是四人小间，公共洗漱间，到处都有免费热水供应，室友非常nice，在寝室的消磨的时光也是欢乐多多。浴室是那种没有单独隔间，几十个人一起洗，食堂也比我想象中的菜品多很多，就是价格有点贵。。。我在这一般7点就起了，刚好干的上北京第一缕阳光，虽然有的时候给雾遮住了，但至少有那麽一次我看到了，没有毒雾，宿舍窗户后面小路边一排高耸的树叶都掉光了的杨树，太阳从后面升起，天色渐变。宿舍后面还有个篮球场，我打了一次球，北方人打球不用脑子，使劲用身体往里冲，没有传球，我费了好大功夫才把几个陌生人联繫起来打出了传切配合，不过球没气，运球比较憋屈，一场下来也没出手几次，脱离了暖气的北京还是很恐怖的，没有热身就这麽打球一场球下来手都是冷冰冰的。
<a name="more"></a>
上课的班级是小班，其中还是有些认识的人，除了室友还有个长沙GRE同班的湖大小女生，或许在她眼里我才是小= =。北京的妹子当然的是个各种高大，也见过了不少白富美，当然大部分都是hard to get，我们班上的平均水平比我想象中差点，不过还是有亮点，每天我还打算以抹茶味百醇打头，以我有次忘带写作书借了妹子一本书爲契机，以“A Lannister always pays his debts”爲藉口神搭讪一次。可能比较悲剧的是，Imp可能就是我以后的发展目标了，还好我不是很排斥用给钱的方式打猎，那麽我只需要有足够的钱我就能体验各种类型的猎物，可惜这只是找不到真爱无奈的一种发泄消磨时光的方式。</p>
<p>人事物都是缘，碰到了，就靜靜的去感受。</p>
]]></content>
    <category scheme="http://shujian.me//tags/北京/" term="北京"/>
    <category scheme="http://shujian.me//tags/新東方/" term="新東方"/>
    <category scheme="http://shujian.me//tags/妙峰山/" term="妙峰山"/>
    <category scheme="http://shujian.me//tags/GRE/" term="GRE"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[北京之旅]]></title>
    <link href="http://shujian.me//2013/01/24/welcome-to-beijing/"/>
    <id>http://shujian.me//2013/01/24/welcome-to-beijing/</id>
    <published>2013-01-23T16:00:00.000Z</published>
    <updated>2013-08-01T04:53:16.259Z</updated>
    <content type="html"><![CDATA[<h2>起</h2>
<p>因为北京大雾，在黄花机场延误了一天一夜，所幸我没有后续订车票，没有脾气不好心态淡定的看书，航空公司也处理的很及时（晚上住的宾馆非常好，还送了3顿饭），第二天上午最终起飞了，第一次坐飞机，晴空万里，飞机底下是云山云海，非常享受在窗边沐浴着第一束阳光，脱下外套喝着冰咖啡背红宝（好吧，我承认我是有点过了）。</p>
<h2>承</h2>
<p>一晃眼，大三上学期就过去了，大学也就快过完了，回头想想这段经历，总是感觉学到了什麽又彷彿什麽都学不到，前几天才看了一篇关于yardlife的文章，讲述的是博士生处于校园学习生活的中心，中心极度幽静，每个人都拼了命的勤奋，在简历上留下败笔是不允许的。可能我觉得前几年的生活不如意的地方就在于我还给自己留下了时间去挥霍，去停留，或者说我只是在浪费我的天赋。这个学期开始的确是有了很大变化，用心的去观察学习方法，去运用用最短的时间把成绩追上来同时还要关注最新的技术发展，不断去吸收新的价值观，我本是个特别特立独行，喜欢按照自己的思维习惯来行事，但是有时候我的方法并不见得取得很好的效果,现在才慢慢懂了规则，世界的运转并不是按照我的规则来，它有它的规则，大大小小的世界都有它的规则，大大小小的人羣里都有自己的规则，放眼自己想要取得的成就，个人的喜怒哀乐都不应该成爲绊脚石，更不应该因爲自己的喜怒哀乐去抵抗规则，只有去适应他，慢慢的积攒能量，有朝一日如果我能够去改变它，我一定会毫不犹豫的去做。这次去北京，就是爲了去赎我的任性犯下的错。去找实习，去新东方，或者是去感受下视界之外的生活。
<a name="more"></a></p>
<h2>轉</h2>
<p>北京起雾，空气很差，下雪，人很杂，纽约也是一样，不是我想要的生活，我来拿了我要的我就走。乐圣比我想象中要nice很多，我惊讶于首次面试就见到了他，没有一点架子，年轻，有激情，我相信跟着他我能学到很多东西。新东方之行也是非常顺利，宿舍条件比我想象中好很多，一路上包括在宿舍也交了很多新朋友。我总是喜欢睁大眼睛去望着一切，去看，去领悟，不同的人有不同的生活目标，跟你可能交集仅限于此或者可能从来就没有过交集。看惯了很多人事之后终于淡定了，行走江湖就应该像洪七一样，用一颗简单的心去翻阅高山的另一面，去证明，那不是沙漠。</p>
<h2>合</h2>
<p>不管怎样，人生如棋，落子无悔。我选择了自己的道路，就应该坚定顽强的走下去，我也不知道我的未来会发生些什么，毕竟,相遇就是缘。</p>
]]></content>
    <category scheme="http://shujian.me//tags/北京/" term="北京"/>
    <category scheme="http://shujian.me//tags/新东方/" term="新东方"/>
    <category scheme="http://shujian.me//tags/缘护天下/" term="缘护天下"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[基于webrtc构建跨平台视频聊天室的阶段研究]]></title>
    <link href="http://shujian.me//2012/12/18/webrtc/"/>
    <id>http://shujian.me//2012/12/18/webrtc/</id>
    <published>2012-12-18T00:00:00.000Z</published>
    <updated>2013-08-01T05:24:54.451Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>WebRTC is a free, open project that enables web browsers with Real-Time Communications (RTC) capabilities via simple Javascript APIs. The WebRTC components have been optimized to best serve this purpose. </p>
</blockquote>
<h2>简介</h2>
<p>由于计算机网络课程设计以及参加一个相关编程比赛的需要，本人尝试利用websocket和webrtc技术搭建一个跨平台的实时视频聊天室,<a href="https://github.com/zsj2145676/webrtc.chatdemo">项目地址在此</a></p>
<h2>问题</h2>
<p>项目采用热门的nodejs开发，参考了webrtc.io的lib库，实际使用的时候需要将Chatlib.js和client.js的host地址统一到本机的ip地址。但是在尝试开发pc与mobile的视频聊天的时候出现了一些问题(本人pc用的linux chrome 25,mobile终端用的ipad2).</p>
<ul>
<li>移动终端的浏览器不支持webrtc</li>
<li>sony ericsson出了一款支持webrtc的浏览器bowser，但是我的代码拿不到peerconnection，基于其官方sample code修改之后也拿不到</li>
<li>chrome和ericsson的webkit标准不同，其video标签的标准也不同（h.264和vp8）</li>
</ul>
<p><a name="more"></a></p>
<h2>总结</h2>
<p>webrtc的潜力还是非常巨大，从Google、Mozilla、Sony Ericsson等巨头的纷纷加入就可以看出来，但是现在的开发者社区还不够活跃，而且在瓷器国并且处于pptp被封杀的情况下，twitter、youtube、google group等非常有用的资源并不容易获得，进一步加大了国人参与webrtc开发的难度。现在只能持续关注webrtc，其标准还相当不稳定。</p>
<h2>参考文献</h2>
<ul>
<li><a href="https://labs.ericsson.com/apps/bowser/sample-code">Sony Ericsson Labs Sample code</a>  </li>
<li><a href="http://flashphoner.com/html5-webrtc-phone-not-yet">HTML5-WebRTC phone? Not yet.</a> </li>
<li><a href="http://www.programmer.com.cn/4239/">VP8的前途与使命</a></li>
</ul>
]]></content>
    <category scheme="http://shujian.me//tags/webrtc/" term="webrtc"/>
    <category scheme="http://shujian.me//tags/websocket/" term="websocket"/>
    <category scheme="http://shujian.me//tags/nodejs/" term="nodejs"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[「算法导论」第9章中位数和顺序统计学的分析与其C语言的实现]]></title>
    <link href="http://shujian.me//2012/11/21/find-the-kth-large/"/>
    <id>http://shujian.me//2012/11/21/find-the-kth-large/</id>
    <published>2012-11-21T00:00:00.000Z</published>
    <updated>2013-08-01T05:25:40.419Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本章讨论从一个由n个不同数值构成的集合（数组）中选择其第i个顺序统计量的问题。</p>
</blockquote>
<p>其实问题可以转化为：<strong>有一个大小为n的数组A[0,1,2,…,n-1]，求其中第k大的数</strong><br>该问题还可以变形为：<strong>有一个大小为 n的数组A[0,1,2,…,n-1]，求其中前k大的数</strong></p>
<p>以上问题都可以形式化地定义为选择问题(selection problem),时间复杂度可以控制在O(n)的范围内。</p>
<h2>简单的冒泡选择</h2>
<p>轮循数组，每次将最大的数冒泡到数组右边，对每次冒泡计数，达到k次之后停止算法，返回从右起第k个数，时间复杂度为O(n*k)</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="keyword">int</span> bubbleSelected ( <span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> k ) {
    <span class="keyword">int</span> temp;
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> j;

    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++ ) {
        <span class="keyword">for</span> ( j = i + <span class="number">1</span> ; j &lt; n; j++ ) {
            <span class="keyword">if</span> ( a[i] &lt; a[j] ) {
                swap ( &a[i], &a[j] );
            }
        }

        <span class="keyword">if</span> ( i &gt; k - <span class="number">1</span> ) {
            <span class="keyword">break</span>;
        }
    }

    <span class="keyword">return</span> a[k - <span class="number">1</span>];
}
</pre></td></tr></table></figure>

<p><a name="more"></a></p>
<h2>结合分治算法的随机快速选择</h2>
<p>以快速排序算法为模型对输入数组进行递归划分，但是只处理划分的一边，时间复杂度为(n*log2k)</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre><span class="keyword">int</span> new_random ( <span class="keyword">int</span> <span class="keyword">min</span>, <span class="keyword">int</span> <span class="keyword">max</span> ) {
    <span class="keyword">return</span> ( <span class="keyword">min</span> + ( <span class="keyword">int</span> ) ( ( ( <span class="keyword">float</span> ) <span class="keyword">rand</span>() / RAND_MAX ) * ( <span class="keyword">max</span> - <span class="keyword">min</span> ) ) );
}
void swap ( <span class="keyword">int</span> <span class="variable">*a</span>, <span class="keyword">int</span> <span class="variable">*b</span> ) {
    <span class="keyword">int</span> c = <span class="variable">*a</span>;
    <span class="variable">*a</span> = <span class="variable">*b</span>;
    <span class="variable">*b</span> = c;
}
<span class="keyword">int</span> <span class="keyword">partition</span> ( <span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r ) {
    <span class="keyword">int</span> i = p - <span class="number">1</span>, j;

    <span class="keyword">for</span> ( j = p; j &lt; r; j++ ) {
        <span class="keyword">if</span> ( A[j] &gt;= A[r] ) {
            i++;
            swap ( &A[i], &A[j] );
        }
    }

    swap ( &A[i + <span class="number">1</span>], &A[r] );
    <span class="keyword">return</span> i + <span class="number">1</span>;
}
<span class="keyword">int</span> randomize_partition ( <span class="keyword">int</span> A[], <span class="keyword">int</span> p, <span class="keyword">int</span> r ) {
    <span class="keyword">int</span> i = new_random ( p, r );
    swap ( &A[i], &A[r] );
    <span class="keyword">return</span> <span class="keyword">partition</span> ( A, p, r );
}

<span class="keyword">int</span> randomized_select ( <span class="keyword">int</span> data[], <span class="keyword">int</span> p, <span class="keyword">int</span> r, <span class="keyword">int</span> k ) {
    <span class="keyword">if</span> ( k &gt; ( r - p + <span class="number">1</span> ) ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/*如果选择数大于数组算法返回0*/</span>

    <span class="keyword">if</span> ( p == r ) <span class="keyword">return</span> data[p];

    <span class="keyword">int</span> i = randomize_partition ( data, p, r );
    <span class="keyword">int</span> count = i - p + <span class="number">1</span>;

    <span class="keyword">if</span> ( k &lt;= count )
        <span class="keyword">return</span> randomized_select ( data, p, i, k );
    <span class="keyword">else</span>
        <span class="keyword">return</span> randomized_select ( data, i + <span class="number">1</span>, r, k - count );
}
</pre></td></tr></table></figure>

<h2>构建最大堆的方法</h2>
<p>用O(4*n)的时间对原数组构建最大堆,然后pop出k次，一共的时间复杂度为O(4*n + k *logn)</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="title">void</span> adjustHeap ( int *<span class="typedef">datas, int length, int pos ) <span class="container">{
    <span class="title">int</span> <span class="title">root</span> = <span class="title">pos</span>;
    <span class="title">int</span> <span class="title">child</span> = <span class="title">pos</span> * 2 + 1;

    <span class="title">while</span> ( <span class="title">child</span> &lt; <span class="title">length</span> ) {
        //在左右子节点中寻找较大的与根节点进行比较
        <span class="title">if</span> ( <span class="title">child</span> != <span class="title">length</span> - 1 && <span class="title">datas</span>[<span class="title">child</span>] &lt; <span class="title">datas</span>[<span class="title">child</span> + 1] ) {
            ++<span class="title">child</span>;
        }</span></span>

        <span class="keyword">if</span> ( <span class="typedef">datas[root] &lt; datas[child] ) <span class="container">{
            <span class="title">int</span> <span class="title">temp</span> = <span class="title">datas</span>[<span class="title">root</span>];
            <span class="title">datas</span>[<span class="title">root</span>] = <span class="title">datas</span>[<span class="title">child</span>];
            <span class="title">datas</span>[<span class="title">child</span>] = <span class="title">temp</span>;
        }</span> else <span class="container">{
            <span class="title">break</span>;
        }</span></span>

        /*以子节点为根节点继续向下进行调整*/
        root = child;
        child = root * <span class="number">2</span> + <span class="number">1</span>;
    }
}
<span class="title">void</span> buildHeap ( int *<span class="typedef">datas, int length ) <span class="container">{
    <span class="title">for</span> ( <span class="title">int</span> <span class="title">i</span> = ( <span class="title">length</span> / 2 ) - 1; <span class="title">i</span> &gt;= 0; --<span class="title">i</span> ) {
        /*从最后一个非叶子节点开始进行调整*/
        <span class="title">adjustHeap</span> ( <span class="title">datas</span>, <span class="title">length</span>, <span class="title">i</span> );
    }</span></span>
}
<span class="title">void</span> deleteMaxValue ( int *<span class="typedef">datas, int length ) <span class="container">{
    <span class="title">int</span> <span class="title">temp</span> = <span class="title">datas</span>[0];
    <span class="title">datas</span>[0] = <span class="title">datas</span>[<span class="title">length</span> - 1];
    <span class="title">datas</span>[<span class="title">length</span> - 1] = <span class="title">temp</span>;
    <span class="title">adjustHeap</span> ( <span class="title">datas</span>, <span class="title">length</span> - 1, 0 );
}</span></span>
<span class="title">int</span> findKthMaxValue_three ( int *<span class="typedef">datas, int length, int k ) <span class="container">{
    <span class="title">int</span> <span class="title">kMax</span> = 0;
    /*<span class="title">build</span> <span class="title">heap</span>*/
    <span class="title">buildHeap</span> ( <span class="title">datas</span>, <span class="title">length</span> );

    /*<span class="title">delete</span> <span class="title">head</span> <span class="title">k</span>-1 <span class="title">times</span> ,<span class="title">adjust</span> <span class="title">heap</span>*/
    <span class="title">for</span> ( <span class="title">int</span> <span class="title">i</span> = 0; <span class="title">i</span> &lt; <span class="title">k</span> - 1; <span class="title">i</span>++ ) {
        <span class="title">deleteMaxValue</span> ( <span class="title">datas</span>, <span class="title">length</span> - <span class="title">i</span> );
    }</span></span>

    kMax = <span class="typedef">datas[0];</span>
    return kMax;
}
</pre></td></tr></table></figure>

<h2>利用hash表的选择</h2>
<p>用hash保存数组中元素Si出现的次数，利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大数，平均情况下时间复杂度O(n)</p>
<p>hash数据结构的头文件:</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
</pre></td><td class="code"><pre>typedef <span class="keyword">int</span> KeyType;
typedef enum {
    Empty, Active, Deleted
} KindOfItem;

typedef struct {
    KeyType key;
} DataType;

typedef struct {
    DataType data;
    KindOfItem info;
} HashItem;

typedef struct {
    HashItem <span class="variable">*ht</span>;
    <span class="keyword">int</span> tableSize;
    <span class="keyword">int</span> currentSize;
} HashTable;

<span class="keyword">int</span> Initiate ( HashTable <span class="variable">*hash</span>, <span class="keyword">int</span> mSize ) {
    hash-&gt;tableSize = mSize;
    hash-&gt;ht = ( HashItem * ) malloc ( sizeof ( HashItem ) * mSize );

    <span class="keyword">if</span> ( hash-&gt;ht )
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">else</span> {
        hash-&gt;currentSize = <span class="number">0</span>;
        <span class="keyword">return</span> <span class="number">1</span>;
    }
}

<span class="keyword">int</span> Find ( HashTable <span class="variable">*hash</span>, DataType <span class="keyword">x</span> ) {
    <span class="keyword">int</span> i = <span class="keyword">x</span>.key % hash -&gt; tableSize;
    <span class="keyword">int</span> j = i;

    <span class="keyword">while</span> ( hash -&gt; ht[j].info == Active && hash -&gt; ht[j].data.key != <span class="keyword">x</span>.key ) {
        j = ( j + <span class="number">1</span> ) % hash -&gt; tableSize;

        <span class="keyword">if</span> ( j == i )
            <span class="keyword">return</span> hash -&gt; tableSize;
    }

    <span class="keyword">if</span> ( hash -&gt; ht[j].info == Active )
        <span class="keyword">return</span> j;
    <span class="keyword">else</span>
        <span class="keyword">return</span> -j;
}

<span class="keyword">int</span> Insert ( HashTable <span class="variable">*hash</span>, DataType <span class="keyword">x</span> ) {
    <span class="keyword">int</span> i = Find ( hash, <span class="keyword">x</span> );

    <span class="keyword">if</span> ( i &gt; <span class="number">0</span> )
        <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> ( i != hash -&gt; tableSize ) {
        hash -&gt; ht[-i].data = <span class="keyword">x</span>;
        hash -&gt; ht[-i].info = Active;
        hash -&gt; currentSize++;
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="keyword">int</span> Delete ( HashTable <span class="variable">*hash</span>, DataType <span class="keyword">x</span> ) {
    <span class="keyword">int</span> i = Find ( hash, <span class="keyword">x</span> );

    <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> ) {
        hash -&gt; ht[i].info = Deleted;
        hash -&gt; currentSize--;
        <span class="keyword">return</span> <span class="number">1</span>;
    } <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="number">0</span>;
}
void Destroy ( HashTable <span class="variable">*hash</span> ) {
    free ( hash-&gt;ht );
}
</pre></td></tr></table></figure>

<p>下面是算法：</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="title">int</span> hashselected ( <span class="type">DataType</span> *<span class="typedef">datas, int length, int k ) <span class="container">{
    <span class="type">HashTable</span> <span class="title">myHashTable</span>;
    <span class="title">int</span> <span class="title">m</span> = <span class="title">length</span> + <span class="title">length</span> - 1 ;
    <span class="title">int</span> <span class="title">counter</span>[<span class="title">m</span>];
    <span class="title">int</span> <span class="title">j</span>,  <span class="title">z</span> = 0;

    <span class="title">for</span> ( <span class="title">int</span> <span class="title">n</span> = 0; <span class="title">n</span> &lt; <span class="title">length</span> - 1; <span class="title">n</span>++ ) {
        <span class="title">counter</span>[<span class="title">n</span>] = 0;
    }</span></span>

    <span class="type">Initiate</span> ( &myHashTable, m );

    for ( int i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++ ) {
        <span class="type">Insert</span> ( &myHashTable, <span class="typedef">datas[i] );</span>
    }

    for ( int i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i ) {
        counter[<span class="type">Find</span> ( &myHashTable, <span class="typedef">datas[i] )] += 1;</span>
    }

    for ( j = m - <span class="number">1</span>; j &gt; <span class="number">0</span>; j<span class="comment">-- ) {</span>
        z += counter[j];

        <span class="keyword">if</span> ( k &lt;= z ) {
            <span class="type">Destroy</span> ( &myHashTable );
            return ++j;
        }
    }
}
</pre></td></tr></table></figure>

<h2>特殊情况下的优化计数排序选择</h2>
<p>如果所有N个数都是正整数，且它们的取值范围不太大，可以考虑申请空间，记录每个整数出现的次数，然后再从大到小取最大的K个。比如，所有整数都在（0, MAXN）区间中的话，利用一个数组count[MAXN]来记录每个整数出现的个数（count[i]表示整数i在所有整数中出现的个数）。我们只需要扫描一遍就可以得到count数组。然后，寻找第K大的元素，时间复杂度为确定的线性复杂度。</p>
<figure class="highlight lang-c"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="title">int</span> countselected ( int *<span class="typedef">datas, int length, int k ) <span class="container">{
    <span class="title">int</span> <span class="title">counter</span>[100];
    <span class="title">int</span> <span class="title">i</span>, <span class="title">j</span>, <span class="title">n</span>, <span class="title">z</span> = 0;

    <span class="title">for</span> ( <span class="title">n</span> = 0; <span class="title">n</span> &lt; 100; <span class="title">n</span>++ ) {
        <span class="title">counter</span>[<span class="title">n</span>] = 0;
    }</span></span>

    for ( i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++ ) {
        counter[<span class="typedef">datas[i]] += 1;</span>
    }

    for ( j = <span class="number">99</span>; j &gt; <span class="number">0</span>; j<span class="comment">-- ) {</span>
        z += counter[j];

        <span class="keyword">if</span> ( k &lt;= z ) {
            return ++j;
        }
    }
}`
</pre></td></tr></table></figure>

<h2>其他方法</h2>
<p>维护一个k大小的最小堆，对于数组中的每一个元素判断与堆顶的大小，若堆顶较大，则不管，否则，弹出堆顶，将当前值插入到堆中。时间复杂度O(n*logk)</p>
<p>二分[Smin,Smax]查找结果X，统计X在数组中出现，且整个数组中比X大的数目为k-1的数即为第k大数。时间复杂度平均情况为O(n*logn)</p>
<h2>总结:</h2>
<p>在实际工程中还需要考虑一个api设计的问题，比如n次取数组中k的数，如果每次第一次将数组排好序用了O(nlogn)的时间，剩下的返回第k大的数就只需要O(1)的时间。但是如果每次取都需要部分排序，用了O(n)的时间，取n次就变成了nO(n)。所以，理论学习要跟实际工程需求相结合。</p>
<h2>参考文献</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Selection_algorithm">Selection algorithm</a></li>
<li><a href="http://www.cnblogs.com/zhjp11/archive/2010/02/26/1674227.html">寻找第K大的数的方法总结</a></li>
</ul>
]]></content>
    <category scheme="http://shujian.me//tags/算法/" term="算法"/>
    <category scheme="http://shujian.me//tags/快速排序/" term="快速排序"/>
    <category scheme="http://shujian.me//tags/堆排序/" term="堆排序"/>
    <category scheme="http://shujian.me//tags/时间复杂度/" term="时间复杂度"/>
    <category scheme="http://shujian.me//categories/Algorithm/" term="Algorithm"/>
  </entry>
  <entry>
    <title type="html"><![CDATA[动态规划在unix diff的下的使用]]></title>
    <link href="http://shujian.me//2012/11/21/dp-in-unix-diff/"/>
    <id>http://shujian.me//2012/11/21/dp-in-unix-diff/</id>
    <published>2012-11-21T00:00:00.000Z</published>
    <updated>2013-08-01T05:26:01.931Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>In computing, diff is a file comparison utility that outputs the differences between two files. It is typically used to show the changes between one version of a file and a former version of the same file. Diff displays the changes made per line for text files.</p>
</blockquote>
<h2>简介</h2>
<p>通常情况下diff和patch一起使用，linux中的源代码补丁都是通过diff和patch的配合制作出来的。diff在比较两个文本文件的不同方面很高效，它是基于行的，diff会将两个文件都按照行分成若干部分，然后计算这些行每一行的校验码（最原始的做法是把每一行当成一个字符，但是空间复杂度会比较大，现在的做法是把每一行文本通过hash算法产生一个值，那么文本行的比较就变成了比较hash值，还用一个bit位贮存中间结果，把空间占有率减少到传统做法的1/8，但是算法时间复杂度依然是O(m*n)，没有决定性的提高），之后的问题就是比较这两个文件的所有行的校验码序列的不同了，这就把问题归结为了序列比对（or LCS）的问题。diff用的是动态规划算法，动态规划和贪心算法相似，但是其思想却是相反的，贪心算法保证每一步都是最小代价的，但是不能保证最终代价最小，而动态规划每一步什么也不知道，它从起点开始，只管局部地按照要求将无所谓的结果铺满全局，然后回溯，在这些繁复的数据之间找到一条从开始到最后的一条路径，为何这条路径就是结果呢？因为每一步都符合要求，所以无论如何最终随便一条按照要求的回溯路线都符合要求，可是可以看出，这条回溯路线的结果是一个正确结果但是却不是唯一的结果，正所谓条条大道通罗马。和贪心算法一样，随便的一条回溯路线不一定是最佳的，寻找最佳结果还要靠别的机制，贪心算法比动态规划好的就是靠近最佳结果的几率更大些，而动态规划只是一个结果，它旨在找到一种方案，然而动态规划有自己的优势，就是如果你的模型建的好，那么它可以在每一步很轻松的情况下达到同样的效果，关键就是建模。</p>
<h2>具体实现</h2>
<p>英文版的详细实现过程在<a href="http://www.avatar.se/molbioinfo2001/dynprog/dynamic.html">Dynamic Programming</a>,其中有一点点小错误，但是不影响阅读。同时也可以阅读算法导论15.4最长公共子序列一章。前面已经说明diff算法把2个文件的行分别依次解析为两个校验码序列，形成一个(M+1)行(N+1)列的矩阵，然后引出一条蛇，蛇头勇往直前，呵呵，其实就是往矩阵里面的元素里填数字，从(0,0)一直到(M+1,N+1)的大方向填数字，保证所填的数字单调增长，也就是填入的数字不能比它的参照值小，将要填入的是Vi,j,那么它的参照值就是Vi-1,j-1，Vi-1,j和Vi,j-1，具体怎么做到呢？V值的增加只有一种可能性就是在Pi和Qj相等的情况下，其它情况下都是不增加的，所以Vi,j的值就是三者中最大的，Vi,j的参考值不是有三个吗？那么这种增加的情况和哪个参考值有关联呢？事实上是和对角的那个，也就是和Vi-1,j-1,仔细想一下，只有i和j同步增长才是P和Q的同步推进引起的比较，i和j的单独推进只是P序列或者Q序列的单独向前推进，也就是说在序列比对的时候就是一个gap，这种方式填表很简单，只要有左上，上，左三个值就可以求出当前的这个值，每一步都是那么的局部，最终填完后，找到最大的这个值的位置，很显然是最右下角的这个，然后回溯，怎么回溯呢？一个一个的找到当前值的前驱值所在的位置就可以了，最后将回溯的道路进行标注，得到了P和Q的两条路径，每写一个字符，如果路径和字符序列的方向垂直，那么就写一个空格，最终的结果就是diff的结果，很巧妙吧。不过以上的方式回溯写出来的路径不止一条，每一条路径都是一个结果。
<a name="more"></a></p>
<h2>总结</h2>
<p>动态规划相比贪心都是局部的对既定规律的模仿，但是在diff中动态规划的算法部分并没有跟全局联系起来，直到完成了整个矩阵的填充过程才在回溯的时候和全局联系起来找到一条结果，但是不一定是最优的结果，贪心算法则一直显的很努力，每一步都想要靠近最优的结果。</p>
<h2>参考文献</h2>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Diff">diff</a></li>
<li><a href="http://en.wikipedia.org/wiki/Diff3">diff3</a></li>
<li><a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem">Longest common subsequence problem</a></li>
<li><a href="http://www.linuxsky.org/doc/admin/200712/213.html">diff和patch使用指南</a></li>
<li><a href="http://binfo.ym.edu.tw/emboss/Apps/diffseq.html">EMBOSS:diffseq</a></li>
<li><a href="http://networking.ctocio.com.cn/289/12393789.shtml">diff指令</a></li>
<li><a href="http://www.avatar.se/molbioinfo2001/dynprog/adv_dynamic.html">Advanced Dynamic Programming Tutorial</a></li>
</ul>
]]></content>
    <category scheme="http://shujian.me//tags/算法/" term="算法"/>
    <category scheme="http://shujian.me//tags/diff/" term="diff"/>
    <category scheme="http://shujian.me//tags/动态规划/" term="动态规划"/>
    <category scheme="http://shujian.me//tags/回溯/" term="回溯"/>
  </entry>
</feed>
